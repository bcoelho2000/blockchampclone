<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>My Block Champ Clone</title>
    <style media="screen">
      .gameContainer
      {
        width: 100%;
        align-items: center;
        align-content: center;
      }

      .grid-container {
        display: inline-grid;
        grid-template-columns: 50px 50px 50px 50px 50px 50px 50px 50px 50px 50px;
        grid-gap: 1px;
        background-color: #8fffdb;
        color: #444;
        border: solid 5px black;
        border-radius: 33px;
        padding: 25px;
      }

      .nextpieces-container {
        display: inline-grid;
        grid-template-columns: 50px 50px 50px 50px 50px;
        grid-gap: 1px;
        background-color: #fff;
        color: #444;
        border: solid 5px black;
        border-radius: 25px;
        padding: 21px;
      }

      .grid-cell {
        background-color: #444;
        color: #fff;
        border-radius: 5px;
        padding: 25px;
        font-size: 150%;
      }

      .grid-cell-full {
        padding: 0px;
      }

      .grid-cell-full .block {
        background-color: #444;
        color: #fff;
        border-radius: 5px;
        padding: 25px;
        font-size: 150%;
      }

    </style>
    <script type="text/javascript">
      let game = null;

      function init()
      {
        game = new Game();
      }

      function testAddNewBlocks()
      {
        game.board.addNewBlockAndRender(new Block("#000000", 1), 0, 0);
        game.board.addNewBlockAndRender(new Block("#000011", 1), 0, 1);
        game.board.addNewBlockAndRender(new Block("#000022", 1), 0, 2);
      }

      const getRandomNumber = (min, max) =>
      {
        return Math.floor(Math.random() * (max - min) + min);
      };

      function Game()
      {
        this.pieceColors = ["#93CB4C", "#F170A0", "#2290FF", "#FCBE5B", "#A35ECD"];
        this.piecesMatrix = new Array();
        this.generatePieces = function()
        {
          // This is just a temporary thing because this function will eventually
          // generete random pieces with random score points

          this.piecesMatrix.push([  [2, 2, 2],
                                    [0, 0, 2],
                                    [0, 0, 2]
                                  ]);

          this.piecesMatrix.push([  [5, 5, 5],
                                    [5, 5, 5],
                                    [5, 5, 5]
                                  ]);

          this.piecesMatrix.push([  [3, 0, 0],
                                    [3, 0, 0],
                                    [3, 3, 3]
                                  ]);

          this.piecesMatrix.push([  [2, 2],
                                    [2, 0]
                                  ]);
        };
        this.generatePieces();

        /*
        Add a random piece to the 'board' starting on position 'x' and 'y'
        */
        this.addRandomPiece = function(board, x, y)
        {
          let pieceColor = this.pieceColors[getRandomNumber(0,this.pieceColors.length)];
          let pieceMatrix = this.piecesMatrix[getRandomNumber(0,this.piecesMatrix.length)];

          for(let boardX = 0; boardX < board.grid.length;++boardX)
          {
            for(let boardY = 0; boardY < board.grid[boardX].length; ++boardY)
            {
              let block = null;
              if(
                boardX < pieceMatrix.length &&
                boardY < pieceMatrix[boardX].length &&
                pieceMatrix[boardX][boardY]!=0)
              {
                block = new Block(pieceColor, pieceMatrix[boardX][boardY]);
              }
              /*
              The idea here is to add a new Block EVEN IF it's null because
              we want to
              */
              board.addNewBlockAndRender(block, boardX, boardY, true);
            }
          }
        };

        this.board = new Board("boardID", "grid-container", 10, 10);
        this.board.createGrid();
        this.board.render();

        this.nextPieces = new Board("nextPiecesID", "nextpieces-container", 5, 5)
        this.nextPieces.createGrid();
        this.nextPieces.render();
        this.addRandomPiece(this.nextPieces);

      }

      function Board(viewID, className, width, height)
      {
        console.log("Board ctor start");
        this.view = document.getElementById(viewID);
        this.view.className = className; //https://www.w3schools.com/css/css_grid.asp
        this.width = width;
        this.height = height;
        this.grid = null;

        this.createGrid = function()
        {
          console.log("Board.createGrid start");
          if(this.view!=null && this.view.hasChildNodes())
          {
              for(let childIdx = 0; childIdx < this.view.childNodes.length; ++childIdx)
                this.view.removeChild(this.view.childNodes[childIdx]);
          }

          this.grid = new Array(width);
          for(let w=0; w < this.width; ++w)
          {
            this.grid[w] = [];
            for(let h=0; h<this.height; ++h)
            {
              /*
              I could create the GridCell and render it right here to prevent
              going through the entire Board (again) and invoke the Render
              for each GridCell.
              However, by doing that we also make it impossible to create a grid WIHTOUT
              rendering it... what if we want to do something BEFORE the render but AFTER
              creating the grid? That would be impossible...
              */
              this.grid[w][h] = new GridCell(this, w, h);
            }
          }
          console.log("Board.createGrid end");
        };

        this.render = function()
        {
          console.log("Board.render start");
          if(this.grid==null)
            return;

            for(let w=0; w < this.width; ++w)
            {
              for(let h=0; h<this.height; ++h)
              {
                this.grid[w][h].render();
              }
            }
          console.log("Board.render end");
        };

        this.addNewBlockAndRender = function(block, x, y, override=false)
        {
          /*
          Adds a new block to the Board and renders it. Returns true.
          If there was an existing block, it doesn't replace it. Returns false.
          */

          console.log("Board.addNewBlock: "+block+" "+x+" "+y+" override:"+override);

          if(!(this.grid!=null && this.grid[x][y]!=null))
          {
            console.log("Grid was not initialized.")
            // TO THINK: should we call this.createGrid() automatically?
            //  usually I don't like "magic" but this could be a fail safe approach.
            return false;
          }

          if(block!=null || override)
          {
            this.grid[x][y].setBlock(block)
            this.grid[x][y].render();
            console.log("Board.addNewBlock true");
            return true;
          }
          console.log("Board.addNewBlock false");
          return false;
        };

        /*this.setBlock = function (block, x, y)
        {
          if(block != null && this.grid != null)
          {
              this.grid[x][y].setBlock(block);
          }
        }*/

        console.log("Board ctor end");
      }


      function GridCell(boardRef, x, y)
      {
        console.log("GridCell ctor: "+boardRef+" "+x+" "+y);
        this.board = boardRef;
        this.x = x;
        this.y = y;
        this.view = null;
        this.block = null;

        this.createView = function()
        {
          this.view = document.createElement("div");
          this.view.className = "grid-cell";
          this.view.id = "grid-cell-id-"+x+y;
          console.log("GridCell.render adding new "+this.view.id);
          this.board.view.appendChild(this.view);

        };
        this.createView();

        this.setBlock = function(block)
        {
          /*
          if the caller wants to setBlock then this function wont check
            if the block exists before it sets.

            This way this approach can be used to overlap/override existing blocks
            and even to erase an existing block by calling this with block = null
          */
          this.block = block;
          if(this.block!=null)
          {
            this.block.setGridCell(this);
          }
        };

        this.hasBlock = function()
        {
          return this.block!=null;
        }

        this.render = function()
        {
          console.log("GridCell.render start");
          if(this.block != null)
          {
            console.log("GridCell.render invoke block.render()");
            this.block.render();
          }
          else
          {
            // Render an "empty block"
            this.view.className = "grid-cell";
            this.view.id = "grid-cell-id-"+x+y;
            if(this.view.hasChildNodes())
            {
              for(let childIdx = 0; childIdx < this.view.childNodes.length; ++childIdx)
                this.view.removeChild(this.view.childNodes[childIdx]);
            }
          }
          console.log("GridCell.render end");
        };
      }

      function Block(color, points)
      {
        console.log("Block.ctor() start");
        this.gridCell = null;
        this.color = color;
        this.points = points;
        this.view = null;

        this.setGridCell = function(gridCellRef)
        {
          // sets the GridCell and returns info on if there was an existing value or not.

            let overrideCell = this.gridCell!=null;
            this.gridCell = gridCellRef;
            return overrideCell;
        };

        this.render = function(htmlContainer=null)
        {
          if(this.gridCell==null)
          {
            console.log("Block.render() - gridCell is null")
            return;
          }

          if(htmlContainer==null)
          {
            /*
            improvement: it would be best if the Block wouldn't have to worry about
            adapting/changing anything at the GridCell.view level...

            This might be solved if the render returns the htmlElement and let the caller figure this out.
            */
            console.log("Block.render() - setting htmlContainer to gridCell.view")
            htmlContainer = this.gridCell.view;
          }

          this.view = document.createElement("div");
          this.view.className = "block";
          this.view.style.backgroundColor = color;
          this.view.id = "block-id"+this.gridCell.x+this.gridCell.y;

          htmlContainer.className = "grid-cell grid-cell-full";
          if(htmlContainer.hasChildNodes())
          {
            for(let childIdx = 0; childIdx < htmlContainer.childNodes.length; ++childIdx)
              htmlContainer.removeChild(htmlContainer.childNodes[childIdx]);
          }
          htmlContainer.appendChild(this.view);
        };

        console.log("Block.ctor() finish");
      }

    </script>
  </head>
  <body onload="init()">
    <h1>Welcome to my Block Champ Clone</h1>
    <div class="gameContainer">
      <div id="boardID">
      </div>
      <div id="nextPiecesID">
      </div>
    </div>
    <div id="controls">
      <input type="button" name="Get Random Piece" value="testAddNewBlocks" onclick="game.addRandomPiece(game.nextPieces)" />
    </div>
  </body>
</html>
